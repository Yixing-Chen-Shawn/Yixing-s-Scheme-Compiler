#lang racket

(require "utils.rkt")
(require "cps.rkt")
(require "desugar.rkt")

(provide closure-convert
         proc->llvm)

; Input Language
;
; e  ::= (let ([x (apply-prim op ae)]) e)
;      | (let ([x (prim op ae ...)]) e)
;      | (let ([x (lambda (x ...) e)]) e)
;      | (let ([x (lambda x e)]) e)
;      | (let ([x (quote dat)]) e)
;      | (apply ae ae)
;      | (ae ae ...)
;      | (if ae e e)
; ae ::= (lambda (x ...) e)
;      | (lambda x e)
;      | x
;      | (quote dat)
;
; Output Language
;
; p ::= ((proc (x x ...) e) ...)
; e ::= (let ([x (apply-prim op x)]) e)
;     | (let ([x (prim op x ...)]) e)
;     | (let ([x (make-closure x x ...)]) e)
;     | (let ([x (env-ref x nat)]) e)
;     | (let ([x (quote dat)]) e)
;     | (clo-app x x ...)
;     | (if x e e)

; removes lambdas and datums from ae and forces them to be let bound.
; symbols are the only ae left after this.
(define (remove-ae-forms ce)
  ; takes a function to call after all aes have been processed
  ; when encountering a non-symbol, it will be expanded to a let form.
  ; After all have been processed, fin (a continuation) is called
  ; to let the caller determine the final expression in the chain of lets.
  (define (expand-aes fin todo done)
    (match todo
      ; we accumulate done backwards, so reverse it at the end.
      ['() (fin (reverse done))]
      [`(,hae ,tae ...)
       (define aearg (gensym 'ae))
       (if (symbol? hae)
           (expand-aes fin tae (cons hae done))
           (remove-ae-forms `(let ([,aearg ,hae]) ,(expand-aes fin tae (cons aearg done)))))]))
  (match ce
    [`(let ([,x (apply-prim ,op ,ae)]) ,letbody)
     (expand-aes (λ (done) `(let ([,x (apply-prim ,op ,@done)]) ,(remove-ae-forms letbody)))
                 (list ae) '())]
    [`(let ([,x (prim ,op ,aes ...)]) ,letbody)
     (expand-aes (λ (done) `(let ([,x (prim ,op ,@done)]) ,(remove-ae-forms letbody))) aes '())]
    [`(let ([,x (lambda ,xargs ,lambody)]) ,letbody)
     `(let ([,x (lambda ,xargs ,(remove-ae-forms lambody))]) ,(remove-ae-forms letbody))]
    [`(let ([,x ',dat]) ,letbody)
     `(let ([,x ',dat]) ,(remove-ae-forms letbody))]
    [`(apply ,aef ,aearglist)
     (expand-aes (λ (done) `(apply ,@done)) `(,aef ,aearglist) '())]
    [`(if ,aec ,et ,ef)
     (expand-aes (λ (done) `(if ,@done ,(remove-ae-forms et) ,(remove-ae-forms ef))) (list aec) '())]
    [`(,aef ,aes ...)
     (expand-aes (λ (done) done) (cons aef aes) '())]))

(define (number->symbol n)
  (string->symbol (number->string n)))


; turn (λ (xs ...) e) -> (λ xs e) -> (λ (xs) e)
; turn (λ xs e) -> (λ (xs) e)
; Turn every lambda and callsite into a 1-arg positional that takes an explicit list
; and change call-sites to make the lists
; This takes the grammar generated by remove-ae-forms,
; so lambdas are guaranteed to be let bound, and the only ae is a symbol.
; a nice side effect is that this pass removes the 'apply' form, as thats what everything becomes!
#|(define (unify-lambdas ce)
  (match ce
    ;;to turn '(x y) as arglist inside of lambda abstraction into
    ;;'(let ((x (prim car arglist)))
    ;; (let ((current-args3480945 (prim cdr arglist)))
    ;; (let ((y (prim car current-args3480945)))
    ;; (unify-lambdas lambda-body))))
    [`(let ([,x (lambda (,x0 ,xs ...) ,body)]) ,letbody)
     (define curargs (gensym 'current-args))
     (define (h arglist left)
       (define narglist (gensym 'current-args))
       (match left
         ['() (unify-lambdas body)]
         [`(,x0) `(let ([,x0 (prim car ,arglist)]) ,(unify-lambdas body))]
         [`(,x0 ,xrest ...) `(let ([,x0 (prim car ,arglist)])
                               (let ([,narglist (prim cdr ,arglist)])
                                 ,(h narglist xrest)))]))
     `(let ([,x (lambda (,curargs) ,(h curargs (cons x0 xs)))]) ,(unify-lambdas letbody))]
    ;;easy case:  turn (λ xs e) -> (λ (xs) e) since xs is a vararg
    [`(let ([,x (lambda ,xs ,body)]) ,letbody) `(let ([,x (lambda (,xs) ,(unify-lambdas body))]) ,(unify-lambdas letbody))]
    [`(let ([,x ,dat]) ,letbody) `(let ([,x ,dat]) ,(unify-lambdas letbody))]
    [`(apply ,func ,arglist) `(,func ,arglist)]
    [`(if ,ec ,et ,ef)  `(if ,ec ,(unify-lambdas et) ,(unify-lambdas ef))]
    ;;nothing will change for apply-prim
    [`(let ([,x (apply-prim ,op ,ae)]) ,letbody) `(let ([,x (apply-prim ,op ,ae)]) ,(unify-lambdas letbody))]
    ;;turning (prim + (a b c d e)) into (prim + a b c d)
    [`(let ([,x (prim ,op ,aes ...)]) ,letbody) `(let ([,x (prim ,op ,@aes)]) ,(unify-lambdas letbody))]
    [`(,aef ,aes ...)
     ;;name for arguement list
     (define listname (symbol-append (gensym 'args) '$ aef '$))
     ;;use prim cons to make a list in cps   
     (define (h func args listname)
       (match args
         ['() `(,func ,listname)]
         [`(,x0 ,xrest ...) `(let ([,listname (prim cons ,x0 ,listname)])
                               ,(h aef xrest listname))]))
     `(let ([,listname '()])
        ,(h aef (reverse aes) listname))]))|#

(define (unify-lambdas ce)
  (match ce
    [`(let ([,x (apply-prim ,op ,ae)]) ,letbody)
     `(let ([,x (apply-prim ,op ,ae)]) ,(unify-lambdas letbody))]
    [`(let ([,x (prim ,op ,aes ...)]) ,letbody)
     `(let ([,x (prim ,op ,@aes)]) ,(unify-lambdas letbody))]
    [`(let ([,x (lambda (,x0 ,xs ...) ,body)]) ,letbody)
     (define curargs (gensym 'current-args))
     (define (h arglist left)
       (define narglist (gensym 'current-args))
       (match left
         ['() (unify-lambdas body)]
         [`(,x0) `(let ([,x0 (prim car ,arglist)]) ,(unify-lambdas body))]
         [`(,x0 ,xrest ...) `(let ([,x0 (prim car ,arglist)])
                               (let ([,narglist (prim cdr ,arglist)])
                                 ,(h narglist xrest)))]))
     `(let ([,x (lambda (,curargs) ,(h curargs (cons x0 xs)))]) ,(unify-lambdas letbody))]
    #|[`(let ([,x (lambda (,xs ...) ,lambody)]) ,letbody)
     (define (listify-lam todo restarg)
       (define nextrestarg (gensym 'arglist))
       (match todo
         ['() (unify-lambdas lambody)]
         ; special case so we dont have a useless binding at the end
         [`(,h)
          `(let ([,h (prim car ,restarg)]) ,(unify-lambdas lambody))]
         [`(,h ,t ...)
          `(let ([,h (prim car ,restarg)])
             (let ([,nextrestarg (prim cdr ,restarg)])
               ,(listify-lam t nextrestarg)))]))
     (define restarg (gensym 'arglist))
     `(let ([,x (lambda (,restarg) ,(listify-lam xs restarg))]) ,(unify-lambdas letbody))]|#
    [`(let ([,x (lambda ,xvararg ,lambody)]) ,letbody)
     `(let ([,x (lambda (,xvararg) ,(unify-lambdas lambody))]) ,(unify-lambdas letbody))]
    [`(let ([,x ,dat]) ,letbody)
     `(let ([,x ,dat]) ,(unify-lambdas letbody))]
    [`(apply ,aef ,aelist)
     `(,aef ,aelist)]
    [`(if ,aec ,et ,ef)
     `(if ,aec ,(unify-lambdas et) ,(unify-lambdas ef))]
    [`(,aef ,aes ...)
     ; to create a list in CPS, we need to construct
     ; each cons-cell 1-by-1. All the appending is just
     ; to make nice arg-names like 'argsXXXX-fname-N
     ; so we can more easily see how far into the args list we are.
     (define (layout-untagged fname args argsname count)
       (match args
         ['() `(,fname ,(symbol-append argsname (string->symbol (number->string count))))]
         [`(,h ,t ...)
          `(let ([,(symbol-append argsname (string->symbol (number->string (add1 count))))
                  (prim cons ,h ,(symbol-append argsname (string->symbol (number->string count))))])
             ,(layout-untagged aef t argsname (add1 count)))]))
     ; This is the base-name of the arg list, we append the arg number to it.
     ; use $ as a separator to avoid name mangling when converting to LLVM IR.
     (define argsname (symbol-append (gensym 'args) '$ aef '$))
     ; we start with null, and then as we consume args, we add to the list.
     `(let ([,(symbol-append argsname (number->symbol 0)) '()])
        ,(layout-untagged aef (reverse aes) argsname 0))]))


; call simplify-ae on input to closure convert, then remove vararg callsites/lambdas
(define/contract (closure-convert cps)
  (-> cps-exp? proc-exp?)
  ;; layout closure environments
  (define (layout-clo-env todo count lam-conv env-name)
    (match todo
      ['() lam-conv]
      [`(,h ,t ...) `(let ([,h (env-ref ,env-name ,count)])
                       ,(layout-clo-env t (+ 1 count) lam-conv env-name))]))
  ;; remove-ae-forms leaves only symbol ae forms.
  ;; unify-lambdas makes all lambdas follow the grammar (lambda (x) e) after this call.
  (define no-varargs-scps (unify-lambdas (remove-ae-forms cps)))

  ;;(displayln "We are converting the input expression:")
  ;;(pretty-print no-varargs-scps)

  ; takes the no-varargs-scps and a list of procs
  ; returns a list containing the top-level expression that was evaluated,
  ; the set of free variables for that expression, and a list of computed procs
  ; while computing that top-level expression.
  (define (bottom-up e)
    (match e
      ;; This is the most interesting case, as this is the *only*
      ;; place which lambdas may be created in our semantics. Thus,
      ;; this is the only form for which we will explicitly have to
      ;; lift out a top-level procedure to implement the lambda.
      [`(let ([,xbnd (lambda (,xvararg) ,elambody)]) ,eletbody)
       ;; Perform closure-conversion on the body, giving us a
       ;; converted expression, set of free variables, and set of
       ;; top-level procs (which we found inside of elambody).
       (match-define `(,lam-conv ,lam-frees ,lam-procs) (bottom-up elambody))
       ;; Same thing as above but for eletbody
       (match-define `(,let-conv ,let-frees ,let-procs) (bottom-up eletbody))
       ;; come up with a name for the closure (the name of the proc)
       ;; and its argument (the environment argument generated in the
       ;; proc form below)
       (define clo-name (symbol-append 'clo '$ xbnd))
       (define env-name (symbol-append 'env '$ xbnd))
       ;; to calculate the set of free variables, remove the set of
       ;; variables from the set of free vars of the lambda.
       (define clo-env-vars (set-remove lam-frees xvararg))
       ;; order those variables as a list in some arbitrary order. The
       ;; order does not matter, it just must be consistent.
       (define ordered-clo-env-vars (set->list clo-env-vars))
       ;; here we build the proc. The only tricky thing here is that
       ;; we call layout-clo-env, which walks through the body of the
       ;; lambda and replaces uses of (e.g.,) `x` with `(env-ref env$0
       ;; 2)` is `x` sits at position 2 within ordered-clo-env-vars.
       (define proc `(proc (,clo-name ,env-name ,xvararg)
                           ,(layout-clo-env ordered-clo-env-vars 0 lam-conv env-name)))
       ;; now return our answer, which transforms the expression to
       ;; explicitly bind a make-closure form, removes necessary
       ;; variables, and returns the new proc appended to the set of
       ;; procs generated from the lambda and let body.
       (list `(let ([,xbnd (make-closure ,clo-name ,@ordered-clo-env-vars)]) ,let-conv)
             (set-remove (set-union let-frees clo-env-vars) xbnd)
             (cons proc (append lam-procs let-procs)))]
      ;; the following two cases are similar to those below. Make sure
      ;; you understand how they are working and please ask questions
      ;; if helpful.
      [`(let ([,xbnd ',dat]) ,eletbody)
       (match-define `(,conv ,frees ,procs) (bottom-up eletbody))
       (list `(let ([,xbnd ',dat]) ,conv)
             (set-remove frees xbnd)
             procs)]
      [`(let ([,xbnd (prim ,op ,aexs ...)]) ,eletbody)
       (match-define `(,conv ,frees ,procs) (bottom-up eletbody))
       `((let ([,xbnd (prim ,op ,@aexs)]) ,conv)
         ,(foldl (λ (x s) (set-add s x)) (set-remove frees xbnd) aexs)
         ,procs)]
      [`(let ([,xbnd (apply-prim ,op ,aexs)]) ,eletbody)
       ;; to handle an apply-prim:
       ;; - First, convert the body eletbody, bind its result expression as 
       ;;   conv, its free variables as frees, and its generated procs as procs.
       ;; - Second, build a result expression
       (match-define `(,conv ,frees ,procs) (bottom-up eletbody))
       (list `(let ([,xbnd (apply-prim ,op ,aexs)]) ,conv)
             (set-remove (set-remove frees aexs) xbnd)
             procs)]
      [`(if ,xc ,et ,ef)
       ;; to handle (if g t f)...
       ;; first, perform closure conversion on the true branch:
       ;;  - bind its answer as ec-conv, its free vars as ec-frees, and its procs as ec-procs
       ;; second, perform closure conversion on the false branch:
       ;;  - bind its answer as ef-conv, its free vars as ef-frees, and its procs as ef-procs
       ;; then, generate a result expression, a result environment, and append the list of
       ;; procs from the true and the false branch.
       (match-define `(,ec-conv ,ec-frees ,ec-procs) (bottom-up et))
       (match-define `(,ef-conv ,ef-frees ,ef-procs) (bottom-up ef))
       (list `(if ,xc ,ec-conv ,ef-conv)
             (set-union ec-frees ef-frees (set xc))
             (append ec-procs ef-procs))]
      [`(,aef ,aex)
       ;; to perform closure conversion of (f x), 
       ;; - generate a `(clo-app f x), that's the answer to this form
       ;; - The set of free variables is {f x}
       ;; - No need to pull out any other top-level procs, because there are 
       ;; no lambda expressions within this expression.
       (list `(clo-app ,aef, aex) (set aef aex) '())]))
  (match-define `(,main-body ,frees ,procs) (bottom-up no-varargs-scps))
  (when (not (set-empty? frees)) (pretty-print `(toplevel-had-frees ,frees)) (error 'bad-program))
  (cons `(proc (main ,(gensym 'mainenv) ,(gensym 'mainargs)) ,main-body) procs))

;; Proc 

; e  ::= (let ([x (lambda (x) e)]) e)
;      | (let ([x (quote dat)]) e)
;      | (let ([x (prim op ae ...)]) e)
;      | (let ([x (apply-prim op ae)]) e)
;      | (if ae e e)
;      | (ae ae)
; ae ::= x
;;"@~a = private unnamed_addr constant ~a c\"~a\\00\", align 8"
; Walk procedures and emit llvm code as a string
(define (llvm-sexpr->llvm-string llvm-sexprs globals)
  (define (format-global g)
    (match-define `(global ,varname ,data) g)
    (define lenstr (format "[~a x i8]" (+ 1 (string-length data))))
    (format "@~a = private unnamed_addr constant ~a c\"~a\\00\", align 8"
            varname lenstr data))
  (define (format-type ty)
    (match ty
      [`(arr ,n x ,ty) (format "[~a x ~a]"
                               n (format-type ty))]
      [`(* ,ptrty) (format "~a*" (format-type ptrty))]
      [`(@ ,ret (,args ...))
       (format "~a(~a)*" (format-type ret) (string-join (map format-type args) ","))]
      ['i64 "i64"]
      ['i32 "i32"]
      ['i8 "i8"]
      ['void "void"]
      ;;['* (pretty-print '*)]
      ;;['% (pretty-print '%)]
      ['ScmObj "%struct.ScmObj"]
      [_ (pretty-display ty) (error 'unexpected-type)]))
  (define (format-value value)
    (match value
      [`(% ,var) (format "%~a" var)]
      [`(@ ,fnname) (format "@~a" fnname)]
      [(? number? n) (~a n)]
      [(? symbol? s) (~a s)]
      [_ (pretty-display value) (error 'unexpected-value)]))
  (define (format-arg arg)
    (match arg
      [`(,ty (% ,argname)) (format "~a %~a" (format-type ty) argname)]
      [`(,ty getelementptr inbounds ,lenarrty ,lenarrptrty (@ ,globname) ,ty0 ,v0 ,ty1 ,v1)
       (format "~a getelementptr inbounds (~a, ~a @~a, ~a ~a, ~a ~a)"
               (format-type ty) (format-type lenarrty) (format-type lenarrptrty)
               globname (format-type ty0) v0 (format-type ty0) v1)]
      ; TODO: this is a suspect line, should probably make some llvm-type? predicate...
      [`(,ty ,val) (format "~a ~a" (format-type ty) val)]
      [_ (pretty-display arg) (error 'unexpected-arg)]))
  (define (format-statement statement)
    ;(pretty-display statement)
    (match statement
      [`(% ,fnname (,args ...))
       (format "%~a(~a)" fnname (string-join (map format-arg args) ", "))]
      [`(@ ,fnname (,args ...))
       (format "@~a(~a)" fnname (string-join (map format-arg args) ", "))]
      [`(label ,label) (format "~a:" label)]
      ;;added an alloca instruction for later GC 
      [`(,loc = alloca ,ty align ,align)
       (format "~a = alloca ~a, align ~a"
               (format-value loc) (format-type ty) (format-value align))]
      [`(,loc = call ,ty ,fncall)
       (format "~a = call ~a ~a"
               (format-value loc) (format-type ty) (format-statement fncall))]
      [`(musttail call ,cc ,ty ,fncall)
       (format "musttail call ~a ~a ~a" cc (format-type ty) (format-statement fncall))]
      [`(call ,ty ,fncall)
       (format "call ~a ~a"
               (format-type ty) (format-statement fncall))]
      [`(call ,cc ,ty ,fncall)
       (format "call ~a ~a ~a"
               cc (format-type ty) (format-statement fncall))]
      [`(,loc = getelementptr inbounds ,ty ,ptrty ,ptrloc ,idxty ,idxval)
       (format "~a = getelementptr inbounds ~a, ~a ~a, ~a ~a"
               (format-value loc) (format-type ty) (format-type ptrty)
               (format-value ptrloc) (format-type idxty) (format-value idxval))]
      [`(store volatile ,ty ,loc ,ptrty ,ptrloc align ,align)
       (format "store volatile ~a ~a, ~a ~a, align ~a"
               (format-type ty) (format-value loc) (format-type ptrty) (format-value ptrloc) (format-value align))]
      [`(store ,ty ,loc ,ptrty ,ptrloc)
       (format "store ~a ~a, ~a ~a"
               (format-type ty) (format-value loc) (format-type ptrty) (format-value ptrloc))]
      [`(,loc = load ,ty ,ptrty ,vloc align ,align)
       (format "~a = load ~a, ~a ~a, align ~a"
               (format-value loc) (format-type ty) (format-type ptrty)
               (format-value vloc) (format-value align))]
      [`(ret void) "ret void"]
      [`(ret ,ty ,val)
       (format "ret ~a ~a" (format-type ty) (format-value val))]
      [`(,loc = ptrtoint ,fromty ,vloc to ,toty)
       (format "~a = ptrtoint ~a ~a to ~a"
               (format-value loc) (format-type fromty)
               (format-value vloc) (format-type toty))]
      [`(,loc = inttoptr ,fromty ,vloc to ,toty)
       (format "~a = inttoptr ~a ~a to ~a"
               (format-value loc) (format-type fromty)
               (format-value vloc) (format-type toty))]
      ; comparisons
      [`(,loc = icmp ,cmp ,ty ,cmpleft ,cmpright)
       (format "~a = icmp ~a ~a ~a, ~a"
               (format-value loc) cmp (format-type ty)
               (format-value cmpleft) (format-value cmpright))]
      ;(br i1 (% cmp$cmp2323274) label (% truebranch$cmp2323274) label (% falsebranch$cmp2323274))
      ; branching
      [`(br ,ty ,cmp label ,tl label ,fl)
       (format "br ~a ~a, label ~a, label ~a"
               (format-value ty) (format-value cmp) (format-value tl) (format-value fl))]
      [`(comment ,cmt ...)
       (format "; ~a" (string-join (map ~a cmt) " "))]
      [_ (display "fail: ") (pretty-display statement) (error 'unexpected-statement)]))
  (define (format-define def)
    (define (format-arg arg)
      (match-define `(,argtype (% ,argname)) arg)
      (format "~a %~a" (format-type argtype) argname))
    (match def
      [`(define ,cc ,rettype (@ ,name ,args) ,defbody)
       (format "define ~a ~a @~a(~a) {\n~a\n}"
               cc (format-type rettype) name (string-join (map format-arg args) ",")
               (string-join (map format-statement defbody) "\n"))]
      [_ (pretty-display def) (error 'incorrect-define)]))
  (define formatted-globals (string-join (map format-global globals) "\n"))
  (string-append formatted-globals
                 "\n\n"
                 (string-join (map format-define llvm-sexprs) "\n\n")))

;; this function is where you will create the 'llvm-sexpr' that is translated
;; to a string for you.
(define/contract (proc->llvm-sexpr procs)
  (-> proc-exp? (cons/c llvm-sexpr? list?))
  (define main-env (gensym 'mainenv))
  (define main-args (gensym 'mainargs))
  (define sexprs+globs (map llvm-sexpr-convert procs))
  (define globals (apply append (map cdr sexprs+globs)))
  (define sexprs (map car sexprs+globs))
  (cons (append
         (list
          `(define ccc i32 (@ main ())
             (((% ,main-env) = call (* ScmObj) (@ const_init_null ()))
              ((% ,main-args) = call (* ScmObj) (@ const_init_null ()))
              (call tailcc void (@ proc_main ([(* ScmObj) (% ,main-env)]
                                              [(* ScmObj) (% ,main-args)])))
              (ret i32 0))))
         sexprs)
        globals))

(define (llvm-sexpr-convert proc)
  (define (conv-inner inner)
    (match inner
      ;;;;;;;;;;;;;;;;;;;;;;
      ; true-datum binding ;
      ;;;;;;;;;;;;;;;;;;;;;;
      [`(let ([,bnd '#t]) ,letbody)
       (match-define (cons conv glob) (conv-inner letbody))
       (cons (append (list `((% ,(c-name bnd)) = call (* ScmObj) (@ const_init_true ()))) conv)
             glob)]
      ;;;;;;;;;;;;;;;;;;;;;;;
      ; false-datum binding ;
      ;;;;;;;;;;;;;;;;;;;;;;;
      [`(let ([,bnd '#f]) ,letbody)
       (match-define (cons conv glob) (conv-inner letbody))
       (cons (append (list `((% ,(c-name bnd)) = call (* ScmObj) (@ const_init_false ()))) conv)
             glob)]
      ;;;;;;;;;;;;;;;;;;;;;;
      ; null-datum binding ;
      ;;;;;;;;;;;;;;;;;;;;;;
      [`(let ([,bnd '()]) ,letbody)
       (match-define (cons conv glob) (conv-inner letbody))
       (cons (append (list `((% ,(c-name bnd)) = call (* ScmObj) (@ const_init_null ()))) conv)
             glob)]
      ;;;;;;;;;;;;;;;;;;;;;;;;
      ; number-datum binding ;
      ;;;;;;;;;;;;;;;;;;;;;;;;
      [`(let ([,bnd ',(? integer? dat)]) ,letbody)
       (match-define (cons conv glob) (conv-inner letbody))
       (cons (append (list `((% ,(c-name bnd)) = call (* ScmObj) (@ const_init_int ((i64 ,dat))))) conv)
             glob)]
      ;;;;;;;;;;;;;;;;;;;;;;;;
      ; string-datum binding ;
      ;;;;;;;;;;;;;;;;;;;;;;;;
      [`(let ([,bnd ',(? string? dat)]) ,letbody)
       (define globname (c-name (gensym (symbol-append 'global$str$ bnd))))
       ; add 1 for the null byte at the end.
       (define datlen (+ 1 (string-length dat)))
       (match-define (cons conv glob) (conv-inner letbody))
       (cons (append
              (list `((% ,(c-name bnd)) = call (* ScmObj)
                                        (@ const_init_string
                                           ([(* i8)
                                             getelementptr inbounds
                                             [arr ,datlen x i8]
                                             (* [arr ,datlen x i8])
                                             (@ ,globname) i32 0 i32 0]))))
              conv)
             (cons `(global ,globname ,dat) glob))]
      ;;;;;;;;;;;;;;;;;;;;;;;;
      ; symbol-datum binding ;
      ;;;;;;;;;;;;;;;;;;;;;;;;
      [`(let ([,bnd ',(? symbol? symdat)]) ,letbody)
       (define dat (symbol->string symdat))
       (define globname (c-name (gensym (symbol-append 'global$sym$ bnd))))
       ; add 1 for the null byte at the end.
       (define datlen (+ 1 (string-length dat)))
       (match-define (cons conv glob) (conv-inner letbody))
       (cons (append
              (list `((% ,(c-name bnd)) = call (* ScmObj)
                                        (@ const_init_symbol
                                           ([(* i8)
                                             getelementptr inbounds
                                             [arr ,datlen x i8]
                                             (* [arr ,datlen x i8])
                                             (@ ,globname) i32 0 i32 0]))))
              conv)
             (cons `(global ,globname ,dat) glob))]
      ;;;;;;;;;;;;;;;;;;;;;
      ; primitive calling ;
      ;;;;;;;;;;;;;;;;;;;;;
      [`(let ([,bnd (prim ,op ,args ...)]) ,letbody)
       (define stackaddr (gensym 'stackaddr$prim))
       ;;(define listofargs (map c-name args))
       (define name (c-name bnd))
       (match-define (cons conv glob) (conv-inner letbody))
       (cons (append
              (list `((% ,stackaddr) = alloca (* ScmObj) align 8)
                    `((% ,name) = call (* ScmObj)
                                (@ ,(prim-name op)
                                   ,(map (λ (arg) `((* ScmObj) (% ,(c-name arg)))) args)))
                    `(store volatile (* ScmObj) (% ,name) (* (* ScmObj)) (% ,stackaddr) align 8))
              conv)
             glob)]
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ; primitive calling -- apply ;
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      [`(let ([,bnd (apply-prim ,op ,arg)]) ,letbody)
       (define stackaddr (gensym 'stackaddr$applyprim))
       (define name (c-name bnd))
       (match-define (cons conv glob) (conv-inner letbody))
       (cons (append
              (list `((% ,stackaddr) = alloca (* ScmObj) align 8)
                    `((% ,name) = call (* ScmObj)
                                (@ ,(if (equal? op 'promise?)
                                        'applyprim_procedure_63
                                        (applyprim-name op))
                                   (((* ScmObj) (% ,arg)))))
                    `(store volatile (* ScmObj) (% ,name) (* (* ScmObj)) (% ,stackaddr) align 8))
              conv)
             glob)]
      ;;;;;;;;;;;;;;;;;;;;
      ; closure creation ;
      ;;;;;;;;;;;;;;;;;;;;
      [`(let ([,bnd (make-closure ,name ,frees ...)]) ,letbody)
       (define stackaddr (gensym 'stackaddr$makeclosure))
       (define procname (symbol-append 'proc_ name))
       (define cname (c-name bnd))
       (define fptrToInt (gensym 'fptrToInt))
       (define freevars (map (λ (idx freevar) `(call void (@ closure_place_freevar (((* ScmObj) (% ,cname))
                                                                                    ((* ScmObj) (% ,(c-name freevar)))
                                                                                    (i64 ,idx)))))
                             (range (length frees)) frees))
       (match-define (cons conv glob) (conv-inner letbody))
       (cons (append
              (list `((% ,stackaddr) = alloca (* ScmObj) align 8)
                    `((% ,fptrToInt) = ptrtoint (@ void ((* ScmObj) (* ScmObj))) (@ ,procname) to i64)
                    `((% ,cname) = call (* ScmObj) (@ closure_alloc ((i64 ,(length frees)) (i64 (% ,fptrToInt)))))
                    `(store volatile (* ScmObj) (% ,cname) (* (* ScmObj)) (% ,stackaddr) align 8))
              freevars
              conv)
             glob)]
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ; closure environment fetching ;
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      [`(let ([,bnd (env-ref ,envname ,whichfree)]) ,letbody)
       (define stackaddr  (gensym 'stackaddr$env-ref))
       (define name (c-name bnd))
       (match-define (cons conv glob) (conv-inner letbody))
       (cons (append
              (list `((% ,stackaddr) = alloca (* ScmObj) align 8)
                    `((% ,name) = call (* ScmObj) (@ closure_env_get (((* ScmObj) (% ,envname)) (i64 ,whichfree))))
                    `(store (* ScmObj) (% ,name) (* (* ScmObj)) (% ,stackaddr)))
              conv)
             glob)]
      ;;;;;;;;;;;;;;;;;;;;;;;;;
      ; conditional branching ;
      ;;;;;;;;;;;;;;;;;;;;;;;;;
      [`(if ,xc ,et ,ef)
       ; the base name so the generated variables can be identified together.
       (define cmp-base (gensym 'cmp))
       (define truthy? (c-name (symbol-append 'truthy$ cmp-base)))
       (define cmp (c-name (symbol-append 'cmp '$ cmp-base)))
       (define truelabel (c-name (symbol-append 'truebranch '$ cmp-base)))
       (define falselabel (c-name (symbol-append 'falsebranch '$ cmp-base)))
       (match-define (cons (cons etconv etglob) (cons efconv efglob))
         (cons (conv-inner et) (conv-inner ef)))
       (cons
        (append
         (list
          `((% ,truthy?) = call i64 (@ is_truthy_value ([(* ScmObj) (% ,(c-name xc))])))
          `((% ,cmp) = icmp eq i64 (% ,truthy?) 1)
          `(br i1 (% ,cmp) label (% ,truelabel) label (% ,falselabel))
          `(label ,truelabel))
         etconv
         (list `(label ,falselabel))
         efconv)
        (append etglob efglob))]
      ;;;;;;;;;;;;;;;;;;;;;;;
      ; closure application ;
      ;;;;;;;;;;;;;;;;;;;;;;;
      [`(clo-app ,f ,x)
       (define clofunc (gensym 'clofunc))
       (define name (c-name f))
       (define name-1 (c-name x))
       (define genargs (map (λ (arg) `((* ScmObj) (% ,arg))) `(,name-1)))
       ;;(match-define (cons conv glob) (conv-inner x))
       (cons
        (append
         (list `((% ,clofunc) = call (@ void ((* ScmObj) (* ScmObj))) (@ closure_get_fn_part (((* ScmObj) (% ,name)))))
               `(musttail call tailcc void (% ,clofunc ,(append `(((* ScmObj) (% ,name))) genargs)))
               `(ret void))
         `())
        `())
       ]))
  (match-define `(proc (,clo ,env ,args) ,proc-body) proc)
  (define proc-name (symbol-append 'proc_ (c-name clo)))
  ;(pretty-display `(proc ,clo ,env ,args))
  (match-define (cons body-conv body-glob) (conv-inner proc-body))
  (cons `(define tailcc void (@ ,proc-name ([(* ScmObj) (% ,(c-name env))]
                                            [(* ScmObj) (% ,(c-name args))]))
           ,body-conv)
        body-glob))

(define (proc->llvm procs)
  (match-define (cons llvm-sexprs globals) (proc->llvm-sexpr procs))
  (llvm-sexpr->llvm-string llvm-sexprs globals))


;;all the tests below

(define test-3 '(let ((box '1))
                  (let ((x
                         (* (and '3)
                            (if (and) '5 '7)
                            (if (and '3 '11) (and '3 '11) '2)
                            (or '7 '13)
                            (if (or) '2 '7)
                            (or '11 (begin (set! box (* '3 box)) '77))
                            (begin (and (> '5 '3) (set! box (* '3 box)) '#f (begin (set! box (* '3 box)) '1)) '2)
                            (begin (and '#f (begin (set! box (* '3 box)) '2)) '1))))
                    (+ x box))))

(define test-2 '(+
                 (foldl +
                        '0
                        (map (lambda (b) (if b '1 '2)) 
                             (map promise?
                                  (list
                                   '#f
                                   '#t
                                   (delay '0)
                                   (list)
                                   (list '() '())
                                   '#()
                                   '#(0 1)
                                   'yes))))
 
                 (let ([x '0])
                   (let ([p (delay (begin (set! x (+ '1 x)) x))])
                     (let ([v (+ (force p) (force p) (force p))])
                       (+ v x)))))

  )



(define clo-co (closure-convert
                (cps-convert
                 (anf-convert
                  (alphatize
                   (assignment-convert
                    (simplify-core (desugar test-2))))))))
(define a (cps-convert
           (anf-convert
            (alphatize
             (assignment-convert
              (simplify-core (desugar test-2)))))))

(define c '(number? 'a))

;;(eval-core (cps-convert (alphatize (anf-convert (assignment-convert (simplify-core (desugar c)))))))
;;(eval-core (cps-convert (anf-convert (alphatize (assignment-convert (desugar test-2))))))
;;(eval-core (alphatize (anf-convert (assignment-convert (simplify-core (desugar test-2))))))

;;(eval-core (alphatize (assignment-convert (simplify-core (desugar test-2)))))

;;(eval-core (alphatize (assignment-convert (simplify-core (desugar test-2)))))
;;(alphatize (assignment-convert (simplify-core (desugar test-2))))
;;(simplify-core (desugar test-2))

(define b (anf-convert
           (alphatize
            (assignment-convert
             (simplify-core (desugar test-2))))))
#;(define res
    (proc->llvm
     (closure-convert
      (cps-convert
       (anf-convert
        (alphatize
         (assignment-convert
          (simplify-core (desugar test-2)))))))))

#;(define res-partial
    (closure-convert
     (cps-convert
      (anf-convert
       (alphatize
        (assignment-convert
         (simplify-core (desugar test-3))))))))
