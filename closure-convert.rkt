#lang racket

(require "utils.rkt")

(provide closure-convert
         proc->llvm)

; Input Language
;
; e  ::= (let ([x (apply-prim op ae)]) e)
;      | (let ([x (prim op ae ...)]) e)
;      | (let ([x (lambda (x ...) e)]) e)
;      | (let ([x (lambda x e)]) e)
;      | (let ([x (quote dat)]) e)
;      | (apply ae ae)
;      | (ae ae ...)
;      | (if ae e e)
; ae ::= (lambda (x ...) e)
;      | (lambda x e)
;      | x
;      | (quote dat)
;
; Output Language
;
; p ::= ((proc (x x ...) e) ...)
; e ::= (let ([x (apply-prim op x)]) e)
;     | (let ([x (prim op x ...)]) e)
;     | (let ([x (make-closure x x ...)]) e)
;     | (let ([x (env-ref x nat)]) e)
;     | (let ([x (quote dat)]) e)
;     | (clo-app x x ...)
;     | (if x e e)


; removes lambdas and datums from ae and forces them to be let bound.
; symbols are the only ae left after this.
(define (remove-ae-forms ce)
  ; takes a function to call after all aes have been processed
  ; when encountering a non-symbol, it will be expanded to a let form.
  ; After all have been processed, fin (a continuation) is called
  ; to let the caller determine the final expression in the chain of lets.
  (define (expand-aes fin todo done)
    (match todo
      ; we accumulate done backwards, so reverse it at the end.
      ['() (fin (reverse done))]
      [`(,hae ,tae ...)
       (define aearg (gensym 'ae))
       (if (symbol? hae)
           (expand-aes fin tae (cons hae done))
           (remove-ae-forms `(let ([,aearg ,hae]) ,(expand-aes fin tae (cons aearg done)))))]))
  (match ce
    [`(let ([,x (apply-prim ,op ,ae)]) ,letbody)
     (expand-aes (λ (done) `(let ([,x (apply-prim ,op ,@done)]) ,(remove-ae-forms letbody)))
                 (list ae) '())]
    [`(let ([,x (prim ,op ,aes ...)]) ,letbody)
     (expand-aes (λ (done) `(let ([,x (prim ,op ,@done)]) ,(remove-ae-forms letbody))) aes '())]
    [`(let ([,x (lambda ,xargs ,lambody)]) ,letbody)
     `(let ([,x (lambda ,xargs ,(remove-ae-forms lambody))]) ,(remove-ae-forms letbody))]
    [`(let ([,x ',dat]) ,letbody)
     `(let ([,x ',dat]) ,(remove-ae-forms letbody))]
    [`(apply ,aef ,aearglist)
     (expand-aes (λ (done) `(apply ,@done)) `(,aef ,aearglist) '())]
    [`(if ,aec ,et ,ef)
     (expand-aes (λ (done) `(if ,@done ,(remove-ae-forms et) ,(remove-ae-forms ef))) (list aec) '())]
    [`(,aef ,aes ...)
     (expand-aes (λ (done) done) (cons aef aes) '())]))

; turn (λ (xs ...) e) -> (λ xs e) -> (λ (xs) e)
; turn (λ xs e) -> (λ (xs) e)
; Turn every lambda and callsite into a 1-arg positional that takes an explicit list
; and change call-sites to make the lists
; This takes the grammar generated by remove-ae-forms,
; so lambdas are guaranteed to be let bound, and the only ae is a symbol.
; a nice side effect is that this pass removes the 'apply' form, as thats what everything becomes!
(define (unify-lambdas ce)
  'todo)

; call simplify-ae on input to closure convert, then remove vararg callsites/lambdas
(define/contract (closure-convert cps)
  (-> cps-exp? proc-exp?)
  
  ;; remove-ae-forms leaves only symbol ae forms.
  ;; unify-lambdas makes all lambdas follow the grammar (lambda (x) e) after this call.
  (define no-varargs-scps (unify-lambdas (remove-ae-forms cps)))

  ; takes the no-varargs-scps and a list of procs
  ; returns a list containing the top-level expression that was evaluated,
  ; the set of free variables for that expression, and a list of computed procs
  ; while computing that top-level expression.
  (define (bottom-up e)
    (match e
      [`(,aef ,aex) (list `(clo-app ,aef, aex) (set aef aex) '())]
      [_ 'todo]))
  (match-define `(,main-body ,frees ,procs) (bottom-up no-varargs-scps))
  (when (not (set-empty? frees)) (pretty-print `(toplevel-had-frees ,frees)) (error 'bad-program))
  (cons `(proc (main ,(gensym 'mainenv) ,(gensym 'mainargs)) ,main-body) procs))

;; Proc 

; e  ::= (let ([x (lambda (x) e)]) e)
;      | (let ([x (quote dat)]) e)
;      | (let ([x (prim op ae ...)]) e)
;      | (let ([x (apply-prim op ae)]) e)
;      | (if ae e e)
;      | (ae ae)
; ae ::= x

; Walk procedures and emit llvm code as a string
(define (llvm-sexpr->llvm-string llvm-sexprs globals)
  (define (format-global g)
    (match-define `(global ,varname ,data) g)
    (define lenstr (format "[~a x i8]" (+ 1 (string-length data))))
    (format "@~a = private unnamed_addr constant ~a c\"~a\\00\", align 8"
            varname lenstr data))
  (define (format-type ty)
    (match ty
      [`(arr ,n x ,ty) (format "[~a x ~a]"
                               n (format-type ty))]
      [`(* ,ptrty) (format "~a*" (format-type ptrty))]
      [`(@ ,ret (,args ...))
       (format "~a(~a)*" (format-type ret) (string-join (map format-type args) ","))]
      ['i64 "i64"]
      ['i32 "i32"]
      ['i8 "i8"]
      ['void "void"]
      ['ScmObj "%struct.ScmObj"]
      [_ (pretty-display ty) (error 'unexpected-type)]))
  (define (format-value value)
    (match value
      [`(% ,var) (format "%~a" var)]
      [`(@ ,fnname) (format "@~a" fnname)]
      [(? number? n) (~a n)]
      [(? symbol? s) (~a s)]
      [_ (pretty-display value) (error 'unexpected-value)]))
  (define (format-arg arg)
    (match arg
      [`(,ty (% ,argname)) (format "~a %~a" (format-type ty) argname)]
      [`(,ty getelementptr inbounds ,lenarrty ,lenarrptrty (@ ,globname) ,ty0 ,v0 ,ty1 ,v1)
       (format "~a getelementptr inbounds (~a, ~a @~a, ~a ~a, ~a ~a)"
               (format-type ty) (format-type lenarrty) (format-type lenarrptrty)
               globname (format-type ty0) v0 (format-type ty0) v1)]
      ; TODO: this is a suspect line, should probably make some llvm-type? predicate...
      [`(,ty ,val) (format "~a ~a" (format-type ty) val)]
      [_ (pretty-display arg) (error 'unexpected-arg)]))
  (define (format-statement statement)
    ;(pretty-display statement)
    (match statement
      [`(% ,fnname (,args ...))
       (format "%~a(~a)" fnname (string-join (map format-arg args) ", "))]
      [`(@ ,fnname (,args ...))
       (format "@~a(~a)" fnname (string-join (map format-arg args) ", "))]
      [`(label ,label) (format "~a:" label)]
      [`(,loc = call ,ty ,fncall)
       (format "~a = call ~a ~a"
               (format-value loc) (format-type ty) (format-statement fncall))]
      [`(musttail call ,cc ,ty ,fncall)
       (format "musttail call ~a ~a ~a" cc (format-type ty) (format-statement fncall))]
      [`(call ,cc ,ty ,fncall)
       (format "call ~a ~a ~a"
               cc (format-type ty) (format-statement fncall))]
      [`(,loc = getelementptr inbounds ,ty ,ptrty ,ptrloc ,idxty ,idxval)
       (format "~a = getelementptr inbounds ~a, ~a ~a, ~a ~a"
               (format-value loc) (format-type ty) (format-type ptrty)
               (format-value ptrloc) (format-type idxty) (format-value idxval))]
      [`(store ,ty ,loc ,ptrty ,ptrloc)
       (format "store ~a ~a, ~a ~a"
               (format-type ty) (format-value loc) (format-type ptrty) (format-value ptrloc))]
      [`(,loc = load ,ty ,ptrty ,vloc align ,align)
       (format "~a = load ~a, ~a ~a, align ~a"
               (format-value loc) (format-type ty) (format-type ptrty)
               (format-value vloc) (format-value align))]
      [`(ret void) "ret void"]
      [`(ret ,ty ,val)
       (format "ret ~a ~a" (format-type ty) (format-value val))]
      [`(,loc = ptrtoint ,fromty ,vloc to ,toty)
       (format "~a = ptrtoint ~a ~a to ~a"
               (format-value loc) (format-type fromty)
               (format-value vloc) (format-type toty))]
      [`(,loc = inttoptr ,fromty ,vloc to ,toty)
       (format "~a = inttoptr ~a ~a to ~a"
               (format-value loc) (format-type fromty)
               (format-value vloc) (format-type toty))]
      ; comparisons
      [`(,loc = icmp ,cmp ,ty ,cmpleft ,cmpright)
       (format "~a = icmp ~a ~a ~a, ~a"
               (format-value loc) cmp (format-type ty)
               (format-value cmpleft) (format-value cmpright))]
      ;(br i1 (% cmp$cmp2323274) label (% truebranch$cmp2323274) label (% falsebranch$cmp2323274))
      ; branching
      [`(br ,ty ,cmp label ,tl label ,fl)
       (format "br ~a ~a, label ~a, label ~a"
               (format-value ty) (format-value cmp) (format-value tl) (format-value fl))]
      [`(comment ,cmt ...)
       (format "; ~a" (string-join (map ~a cmt) " "))]
      [_ (display "fail: ") (pretty-display statement) (error 'unexpected-statement)]))
  (define (format-define def)
    (define (format-arg arg)
      (match-define `(,argtype (% ,argname)) arg)
      (format "~a %~a" (format-type argtype) argname))
    (match def
      [`(define ,cc ,rettype (@ ,name ,args) ,defbody)
       (format "define ~a ~a @~a(~a) {\n~a\n}"
               cc (format-type rettype) name (string-join (map format-arg args) ",")
               (string-join (map format-statement defbody) "\n"))]
      [_ (pretty-display def) (error 'incorrect-define)]))
  (define formatted-globals (string-join (map format-global globals) "\n"))
  (string-append formatted-globals
                 "\n\n"
                 (string-join (map format-define llvm-sexprs) "\n\n")))

;; this function is where you will create the 'llvm-sexpr' that is translated
;; to a string for you.
(define/contract (proc->llvm-sexpr procs)
  (-> proc-exp? (cons/c llvm-sexpr? list?))
  (define main-env (gensym 'mainenv))
  (define main-args (gensym 'mainargs))
  (define sexprs+globs (map llvm-sexpr-convert procs))
  (define globals (apply append (map cdr sexprs+globs)))
  (define sexprs (map car sexprs+globs))
  (cons (append
         (list
          `(define ccc i32 (@ main ())
             (((% ,main-env) = call (* ScmObj) (@ const_init_null ()))
              ((% ,main-args) = call (* ScmObj) (@ const_init_null ()))
              (call tailcc void (@ proc_main ([(* ScmObj) (% ,main-env)]
                                              [(* ScmObj) (% ,main-args)])))
              (ret i32 0))))
         sexprs)
        globals))

(define (llvm-sexpr-convert proc)
  (define (conv-inner inner)
    (match inner
      ;;;;;;;;;;;;;;;;;;;;;;
      ; true-datum binding ;
      ;;;;;;;;;;;;;;;;;;;;;;
      [`(let ([,bnd '#t]) ,letbody)
       (match-define (cons conv glob) (conv-inner letbody))
       (cons (append (list `((% ,(c-name bnd)) = call (* ScmObj) (@ const_init_true ()))) conv)
             glob)]
      ;;;;;;;;;;;;;;;;;;;;;;;
      ; false-datum binding ;
      ;;;;;;;;;;;;;;;;;;;;;;;
      [`(let ([,bnd '#f]) ,letbody)
       'todo]
      ;;;;;;;;;;;;;;;;;;;;;;
      ; null-datum binding ;
      ;;;;;;;;;;;;;;;;;;;;;;
      [`(let ([,bnd '()]) ,letbody)
       'todo]
      ;;;;;;;;;;;;;;;;;;;;;;;;
      ; number-datum binding ;
      ;;;;;;;;;;;;;;;;;;;;;;;;
      [`(let ([,bnd ',(? integer? dat)]) ,letbody)
       'todo]
      ;;;;;;;;;;;;;;;;;;;;;;;;
      ; string-datum binding ;
      ;;;;;;;;;;;;;;;;;;;;;;;;
      [`(let ([,bnd ',(? string? dat)]) ,letbody)
       (define globname (c-name (gensym (symbol-append 'global$str$ bnd))))
       ; add 1 for the null byte at the end.
       (define datlen (+ 1 (string-length dat)))
       (match-define (cons conv glob) (conv-inner letbody))
       (cons (append
              (list `((% ,(c-name bnd)) = call (* ScmObj)
                                        (@ const_init_string
                                           ([(* i8)
                                             getelementptr inbounds
                                             [arr ,datlen x i8]
                                             (* [arr ,datlen x i8])
                                             (@ ,globname) i32 0 i32 0]))))
              conv)
             (cons `(global ,globname ,dat) glob))]
      ;;;;;;;;;;;;;;;;;;;;;;;;
      ; symbol-datum binding ;
      ;;;;;;;;;;;;;;;;;;;;;;;;
      [`(let ([,bnd ',(? symbol? symdat)]) ,letbody)
       (define dat (symbol->string symdat))
       (define globname (c-name (gensym (symbol-append 'global$sym$ bnd))))
       ; add 1 for the null byte at the end.
       (define datlen (+ 1 (string-length dat)))
       (match-define (cons conv glob) (conv-inner letbody))
       (cons (append
              (list `((% ,(c-name bnd)) = call (* ScmObj)
                                        (@ const_init_symbol
                                           ([(* i8)
                                             getelementptr inbounds
                                             [arr ,datlen x i8]
                                             (* [arr ,datlen x i8])
                                             (@ ,globname) i32 0 i32 0]))))
              conv)
             (cons `(global ,globname ,dat) glob))]
      ;;;;;;;;;;;;;;;;;;;;;
      ; primitive calling ;
      ;;;;;;;;;;;;;;;;;;;;;
      [`(let ([,bnd (prim ,op ,args ...)]) ,letbody)
       'todo]
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ; primitive calling -- apply ;
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      [`(let ([,bnd (apply-prim ,op ,arg)]) ,letbody)
       'todo]
      ;;;;;;;;;;;;;;;;;;;;
      ; closure creation ;
      ;;;;;;;;;;;;;;;;;;;;
      [`(let ([,bnd (make-closure ,name ,frees ...)]) ,letbody)
       'todo]
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ; closure environment fetching ;
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      [`(let ([,bnd (env-ref ,envname ,whichfree)]) ,letbody)
       'todo]
      ;;;;;;;;;;;;;;;;;;;;;;;;;
      ; conditional branching ;
      ;;;;;;;;;;;;;;;;;;;;;;;;;
      [`(if ,xc ,et ,ef)
       ; the base name so the generated variables can be identified together.
       (define cmp-base (gensym 'cmp))
       (define truthy? (c-name (symbol-append 'truthy$ cmp-base)))
       (define cmp (c-name (symbol-append 'cmp '$ cmp-base)))
       (define truelabel (c-name (symbol-append 'truebranch '$ cmp-base)))
       (define falselabel (c-name (symbol-append 'falsebranch '$ cmp-base)))
       (match-define (cons (cons etconv etglob) (cons efconv efglob))
         (cons (conv-inner et) (conv-inner ef)))
       (cons
        (append
         (list
          `((% ,truthy?) = call i64 (@ is_truthy_value ([(* ScmObj) (% ,(c-name xc))])))
          `((% ,cmp) = icmp eq i64 (% ,truthy?) 1)
          `(br i1 (% ,cmp) label (% ,truelabel) label (% ,falselabel))
          `(label ,truelabel))
         etconv
         (list `(label ,falselabel))
         efconv)
        (append etglob efglob))]
      ;;;;;;;;;;;;;;;;;;;;;;;
      ; closure application ;
      ;;;;;;;;;;;;;;;;;;;;;;;
      [`(clo-app ,f ,x)
       'todo]))
  (match-define `(proc (,clo ,env ,args) ,proc-body) proc)
  (define proc-name (symbol-append 'proc_ (c-name clo)))
  ;(pretty-display `(proc ,clo ,env ,args))
  (match-define (cons body-conv body-glob) (conv-inner proc-body))
  (cons `(define tailcc void (@ ,proc-name ([(* ScmObj) (% ,(c-name env))]
                                            [(* ScmObj) (% ,(c-name args))]))
           ,body-conv)
        body-glob))


